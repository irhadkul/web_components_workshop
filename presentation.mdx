import future from "@mdx-deck/themes/future";
import highlight from "@mdx-deck/themes/syntax-highlighter-prism";
import { Split } from "@mdx-deck/layouts";
import { Notes } from 'mdx-deck'
import { Title, Slide, Section, Image, theme } from "./adesso";

export const themes = [theme, highlight];

<Title bg={1}>

# Workshop

## Web Components

</Title>

---


<Section bg={2} logo="white">

# Motivation/ Einleitung
<Notes>
    - erzählen wer wir sind
    - warum beschäftigen wir uns mit web components
    - fragen anderen wer die sind und was die machen
    - stellen Agenda für heute
</Notes>

</Section>

---

<Slide>

# Noch Ein JS Framework?
![https://hackernoon.com/how-it-feels-to-learn-javascript-in-2016-d3a717dd577f](./adesso/images/JS-Frameworks.png)

</Slide>

---

<Slide>

# Warum jetzt web componets?

- Frameworks haben eigenes Weg um DOM zu erzeugen und kontrolierren
- verlassen sich auf document.querySelector 
- unterschiedliche vorgehnsweise 
- reagieren auf Seiten-Änderungen auf document Ebene


</Slide>

---

<Slide>

# was sind web components?

"Web components are a set of web platform APIs that allow you to create new custom, reusable, encapsulated HTML tags to use in web pages and web apps."

</Slide>

---

<Slide>

# was bedeutet das genau?
- Möglichkeit eigenes HTML zu definieren und erweitern
- Kleine verschatelte Komponenten 
- Vieles mehr

```html
<dw-cookie visible> Wir verwenden Cookies...</dw-cookie>
```

</Slide>

---

<Slide>

# Specifications

- Custom Elements
- Shadow DOM
- ES Modules
- HTML Template

</Slide>

---

<Slide>

# Specifications

### TODO: über einzelne specs kurz sprechen und kurz Ablauf von spec erwähnen

</Slide>

---

<Slide>

# Specifications

### Specs kurz erklären

</Slide>

---

<Section bg={2} logo="white">

# Custom Elements


</Section>

---

<Slide>

# Custom Elements / Built-in Elements

<Image src="./adesso/images/Element_properties_Ancestry.png" />

<Notes>
- hier soll standard html element Vererbung erklärt werden
</Notes>
 

</Slide>

---


<Slide>

# Built-in Elements
- Built-in Elements Technologie ermöglicht erweiterung eines HTML-Element
- Normales HTML mit der Attribut <b>is</b> ausstatten
#### TODO: built in slides erwietern

</Slide>

---

<Slide>

# Built-in Elements
 ```html
 <input is="dw-input"></input>
 ```

</Slide>

---



<Slide>

# Custom Elements  Boilerplate
```JS
class YourClassName extends HTMLElement{
    constructor(){
        super();
        /* define your element .... */
    }
}
window.customElements.define("your-tag", YourClassName);
```
```html
<your-tag></your-tag>
```
<Notes>
- weil die Erwieterung von built ins nicht ausreicht können wir eigene Elemente erstellen
</Notes>

</Slide>

---

<Slide>

# Custom Elements Constructor
- Definieren eines Custom Elements
```JS
class YourClassName extends HTMLElement{
    constructor(){
        super();
        /* define your element .... */
    }
}
```
<Notes>
- erklären warum wir hier extenden müssen 
- super() kurz erklären
</Notes>
</Slide>

---

<Slide>

# Custom Elements Registry

- Registrieren der Element


```JS
window.customElements.define("your-tag", YourClassName);
```
<Notes>
- in regitry kann man eigene Elemente definieren und auch abfragen welche da sind
</Notes>

</Slide>



---

<Slide>

# Custom Elements 
 ```html
 <dw-input theme="blue"></dw-input>
 ```
<Notes>
- eigenes html, yeah.... aber ist das Valides HTML?
</Notes>
</Slide>

---

<Slide>

# Custom Elements 
1. Custom Elements Tags müssen immer mit "-" geschrieben werden und können nicht einzelne Worte sein
2. können nicht einzelworte sein 

* Falsch:  "meineKomponente" 
* Richtig:  "meine-komponete" 
* Richtig:  "meine-gelbe-komponete" 

</Slide>

---

<Slide>

# Custom Elements 

```JS
class DWInput extends HTMLElement{
    constructor(){
        super()
       /*  */
    }
}
window.customElements.define("dw-input", DWInput);

```
<Notes>
- kleines Beispiel von JS Teil der Custom web componet 
</Notes>

</Slide>

---
<Slide>

# Übung #1

1. Definiere ein eigenes "custom" HTML Tag 
2. Kreiere ein Custom Element Objekt
3. Wenn initialisiert, es soll in JS-definiertes Text rendern (z.B. eigene Name) 

<Notes>
- steht noch offen welches Element wir nehmen können
Mein Vorschlag: 
- Visitenkarte 
*** hat Bild, Name und Email. Das Bild hat src die später ausgetauscht werden kann und auch die Name und Email können per attributen getauscht werden 
</Notes>
</Slide>

---

<Section bg={3} logo="white">

# Shadow DOM


</Section>

---

<Slide>
  
# Shadow DOM  

"Web components are a set of web platform APIs that allow you to create new custom, reusable, <i>encapsulated</i> HTML tags to use in web pages and web apps."

- Fokus auf "encapsulated" 


</Slide>

---

<Slide>

# Shadow DOM  

  - per definition ist es möglich "encapsulated" Komponeten zu kreieren
  - alles innerhalb eine Komponente definiert (HTML, CSS)
    

</Slide>

---

<Slide>

<Image src="./adesso/images/shadow-root-elements.png" />

<Notes>
- erklären dass das shadowRoot ein neues typ von Element ist
- 
</Notes>  

</Slide>

---

<Slide>

```JS
// shadow-root nodeType = 11
// document-fragment
```    
- document-fragment ist vereinfachte version des document
- eine hat kein Einflus auf das andere

<Notes>
- vergleich mit iframes erwähnen 
</Notes>
</Slide>

---

<Slide>
    
# Shadow DOM  

```JS
class DWInput extends HTMLElement{
    constructor(){
       super();
        const shadowRoot = this.attachShadow({mode: 'open'});
        // shadowRoot.appendChild(yourChild);
    }
}
window.customElements.define("dw-input", DWInput);

```
<Notes>
- open vs closed  mode
</Notes>

</Slide>

---

<Slide>

# Übung #2
- Übung #1 mit Shadow DOM erweitern
- Eigenes text jetzt in shadowRoot rendern

</Slide>

---

<Slide>

# Shadow DOM Styles
- Möglichkeit um CSS zu definieren der nur für Komponente gültig ist 

<Notes>
- Beispiel wie andere Framework das schaffen (css Klasse: some_ysda84874)
</Notes>

</Slide>

---

<Slide>

# Shadow DOM Styles
```JS

    constructor(){
       super();
        const shadowRoot = this.attachShadow({mode: 'open'});
        const style = document.createElement('style');
        style.textContent = `p { color: red; }`;
        shadowRoot.appendChild(style);
    }
```

</Slide>

---

<Slide>

# Übung #3
- Eigene shadowRoot Styles definieren

</Slide>

---

<Section bg={5} logo="white">

# HTML Templates/ Slots

</Section>

---

<Slide>

# Html Templates
- Teil der web components Standard 
- Bietet Möglichkeit "reusable" Templates zu definieren 
- definiert in HTML oder JS

</Slide>

---

<Slide>

# Html Templates
```html
<template id="dw-template">
    <p> Das ist ein Text </p>
</template>
// Bleibt auf der Seite unsichtbar
```

</Slide>

---

<Slide>

# Html Templates
- Neues HTML Tag "template"
- Bleibt unsichtbar bis es initialisiert ist
- Soll mit ID ausgesttatet werden 

</Slide>

---

<Slide>

# Html Templates
```JS

    constructor(){
       super();
        const shadowRoot = this.attachShadow({mode: 'open'});
        const template = document.querySelector('#dw-template');
        const templateContent = template.content;
        shadowRoot.appendChild(templateContent.cloneNode(true));
    }
```

</Slide>

---

<Slide>

# Html Templates
- wie gewohnt aus document abfragen
- desen Inhalte ins shadowRoot einfügen

</Slide>

---

<Slide>

# Übung #4
- schreibe eigene HTML template
- füge fie ins shadowRoot ein

</Slide>

---

<Slide>

# Html Slots
- Teil der Template Standard
- Bietet Möglichkeit Platzhalter zu definieren

</Slide>

---

<Slide>

# Html Slots
- auf zwei Stellen definiert:
1. In HTML Teil der web-Komponente
2. In Template HTML

</Slide>

---

<Slide>

# Html Slots 
- In dem HTML Teil der Web-Komponente definieren wir den Inhalt
- Die sind mit der Attribut "Slot" ausgesttatet
```html
<dw-cookie visible> <div slot="cookie-text">Wir verwenden Cookies...</div></dw-cookie>
```

</Slide>

---

<Slide>

# Html Slots 
- In Template definieren wir den Platzhalter
- In Template Tag sind Slots mit eigenem Tag definiert
- Haben entsprechend die Name gesetzt
```html
<template id="dw-cookieTemplate">
    <slot name="cookie-text"></slot>
</template>
```

</Slide>

---

<Slide>

# Html Slots in JS
```JS
    constructor(){
       super();
        const shadowRoot = this.attachShadow({mode: 'open'});
        const template = document.querySelector('#dw-cookieTemplate');
        const templateContent = template.content;
        shadowRoot.appendChild(templateContent.cloneNode(true));
    }
```

</Slide>

---

<Slide>

# Html Slots in HTML
```html
<template id="dw-cookieTemplate">
    <slot name="cookie-text"></slot>
</template>
<dw-cookie visible> <div slot="cookie-text">Wir verwenden Cookies...</div></dw-cookie>
```

</Slide>

---

<Slide>

# Übung #5
- Eigene Slots in Template Definieren
- Inhalt für Slots in der Web-Komponente HTML definieren

</Slide>

---

<Section bg={4} logo="white">

# Callbacks


</Section>

---

<Slide>

# Callbacks
- Bestandteil eine Komponente
- Ermöglichen Kontrolle bei Änderungen

</Slide>

---

<Slide>

# Callbacks
- connectedCallback
- disconnectedCallback
- adoptedCallback
- attributeChangedCallback

</Slide>

---

<Slide>

# connectedCallback
- passiert bei jedem Einfügen, und Schieben der Komponente HTML
- kann mehrmals aufgerufen werden
- wenn die Komponente auf inneren oder ausseren DOM abhängig ist


</Slide>

---

<Slide>

# connectedCallback
```JS
    constructor(){
       super();
    }
    connectedCallback(){
        // bei Zugriff auf DOM 
        // Beispiel: Berechnete Styles abfragen
    }
```

</Slide>

---

<Slide>

# disconnectedCallback
- bei "disconnecten" oder löschen von der Seite 
```JS
    constructor(){
       super();
    }
    disconnectedCallback(){
        // Beispiel: setzte alles auf null 
        // oder remove eventListeners
    }
```

</Slide>

---

<Slide>

# adoptedCallback
- bei Schieben der Komponete zu anderen document, z.B. iframe
- soll nur in komplexen Fällen benutzt werden wo connectedCallback nicht ausreicht

<Notes>
- nur kurz erwähnen, ist nur in komplexen fällen zu benutzen 
</Notes>

</Slide>

---

<Slide>

# adoptedCallback
```JS
    adoptedCallback(){
        // Beispiel: 
        // wechsel der ownerDocument
        // HTML -> iframe mit adoptNode()  
    }
```
</Slide>

---

<Slide>

# attributeChangedCallback
- Ermöglicht Kontrolle über Attributen Änderungen (Add, Edit, Remove)
- Eigene Komponenenten "native-like" machen 
- Bietet dem Anwender Möglichkeit der Inhalt zu Ändern
- Zum Beispiel: regagieren auf "Theme" Attribut Änderung  

</Slide>

---

<Slide>

# attributeChangedCallback
- besteht aus zwei Teilen:
1. callback Methode
2. statisches get "observedAttributes"

</Slide>

---


<Slide>

# attributeChangedCallback
1. callback Methode (attributeChangedCallback)
- wird jedes mal ausgeführt bei Attributen Änderungen

</Slide>

---


<Slide>

# attributeChangedCallback
1. static get observedAttributes
- definieret auf welche Attributen die callback Methode reagieren soll

</Slide>

---

<Slide>

# attributeChangedCallback
```JS
static get observedAttributes(){
    // return ist immer ein Array
    return ['text-color']
}
constructor(){super}
attributeChangedCallback(attrName, oldValue, newValue){}
```

</Slide>

---

<Slide>

# Übung #6
- Die Komponente soll sich wie ein HTML Element Verhalten
- Es soll entsprechend auf Attributen-Änderungen reagieren
- Wenn der Benutzer ein Attribut z.B. "color" ändert, es soll auch in der Komponente angezeigt werden

</Slide>

---

<Section bg={4} logo="white">

# Polyfills


</Section>

---

<Slide>

# Polyfills
- Kleine Bibliotheken die Browser um eine Technoglogie erweitern
- Dadürch können z.B. ältere Versionen von Browsers profitieren

</Slide>

---

<Slide>

# Polyfills
![Source: https://www.webcomponents.org/ 
TODO: Das Bild beschreiben
](./adesso/images/WC-polyfill-status.png)


</Slide>

---

<Slide>

# Polyfills
- Obwohl web componets "living-standard" sind, brauchen ältere Versionen oder verschiedene Browsers polyfills 
- bester polyfill:
https://www.webcomponents.org/polyfills

<Notes>
- TODO:
</Notes>

</Slide>

---

<Slide>

# Polyfills
- können zu Performance reduzierung führen
- manche Tehnologien lassen sich nicht "polyfillen", z.B. shadow DOM in IE 11 (Über shadyCSS möglich)

<Notes>
- shadyCSS macht das gleiche was andere framework machen, kreiert einzigartige css Klassen 
- ist mit Vorsicht zu genießen, vor allem bei langsamere Browsers (paradox)
</Notes>
</Slide>

---

<Slide>

# Polyfills Einbindung
```html
<!-- load the webcomponents loader, which injects the necessary polyfill bundle -->
<script src="node_modules/@webcomponents/webcomponentsjs/webcomponents-loader.js"></script>

<!-- load the element -->
<script type="module" src="my-element.js"></script>

<!-- use the element -->
<my-element></my-element>
```

</Slide>

---

<Section bg={4} logo="white">

# Frameworks


</Section>

---

<Slide>

# Frameworks
## Warum Frameworks?

- Erweitern Funktionalität
- Erleichtern Aufsetzen von Dev Umgebung
- Sparen Boilerplate Code


</Slide>

---

<Slide>

# Frameworks
## Ein paar bekante Frameworks:

1. LitElement
2. Polymer Project
3. Angular Elements
4. Stencil

</Slide>

---

<Slide>

# Frameworks
## LitElement
</Slide>

---


<Slide>

# Frameworks
## Polymer Project
</Slide>

---


<Slide>

# Frameworks
## Angular Elements
</Slide>

---


<Slide>

# Frameworks
## Stencil
</Slide>

---

<Slide>

# Stencil

>Stencil is a toolchain for building reusable, scalable Design Systems. Generate small, blazing fast, and 100% standards based Web Components that run in every browser.

</Slide>

---

<Slide>

# Stencil
- erweitert Webcomponets mit neuen callbacks, props/attributes
- TypeScript per Default
- JSX oder React Style HTML
- Implementiert Dev umgebung
- Polyfills 
- 100% web componetns zu Laufzeit

</Slide>

---

<Slide>

# Stencil
```js
import { Component, Prop, h } from '@stencil/core';
@Component({
  tag: 'my-first-component',
})
export class MyComponent {
  // Indicate that name should be a public property on the component
  @Prop() name: string;

  render() {
    return (
      <p>
        My name is {this.name}
      </p>
    );
  }
}


```

</Slide>

---


<Slide>

# Stencil
```html
<my-first-component name="Max"></my-first-component>
```

</Slide>

---

<Slide>

# Stencil
## Decorators
* @Component() declares a new web component
* @Prop() declares an exposed property/attribute
* @State() declares an internal state of the component
* @Watch() declares a hook that runs when a property or state changes
* @Element() declares a reference to the host element
* @Method() declares an exposed public method
* @Event() declares a DOM event the component might emit
* @Listen() listens for DOM events
// TODO: schöner machen 

</Slide>

---
<Slide>

# Stencil
## Callbacks
* connectedCallback() 
* disconnectedCallback() 
* componentWillLoad() 
* componentDidLoad() 
* componentWillRender() 
* componentDidRender() 
* componentWillUpdate()
* componentDidUpdate()
* render()

// TODO: schöner machen 

</Slide>

---

<Slide>

# Stencil
## Stencil show-off
// TODO: einen Stencil Projekt aufsetzten und zeigen 
</Slide>

---

<Section bg={4} logo="white">

# Implementation bestehende Komponetnen 


</Section>

---

<Slide>

# Implementation bestehende Komponetnen 
- web components sind Valides HTML
- lassen sich in jedes Framework einsetzen 
- größer auswahl einzelne Komponeten z.B.
1. https://www.webcomponents.org/elements
2. https://www.npmjs.com/search?q=keywords:web-components

</Slide>

---

<Slide>

# Implementation bestehende Komponetnen 
- TODO: beschreiben import in bestehendes System oder import als script zu Seite

</Slide>

---
