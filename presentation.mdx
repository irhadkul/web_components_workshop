import future from "@mdx-deck/themes/future";
import highlight from "@mdx-deck/themes/syntax-highlighter-prism";
import { Split } from "@mdx-deck/layouts";
import { Title, Slide, Section, Image, theme } from "./adesso";

export const themes = [theme, highlight];

<Title bg={1}>

# Workshop

## Web Components

</Title>



---


<Section bg={2} logo="white">

# Motivation/ Einleitung


</Section>

---

<Slide>

# Noch Ein JS Framework?

Hier steht Bild mit viele Framework Logos

</Slide>

---

<Slide>

# Warum jetzt web componets?

- Frameworks haben eigenes Weg um DOM zu erzeugen und kontrolierren
- verlassen sich auf document.querySelector 
- unterschiedliche vorgehnsweise 
- reagieren auf Seiten-Änderungen auf document Ebene


</Slide>

---

<Slide>

# was sind web components?

"Web components are a set of web platform APIs that allow you to create new custom, reusable, encapsulated HTML tags to use in web pages and web apps."

</Slide>

---

<Slide>

# was bedeutet das genau?
- Möglichkeit eigenes HTML zu definieren und erweitern
- Kleine verschatelte Komponenten 
- Vieles mehr

```JS
<dw-cookie visible> Wir verwenden Cookies...</dw-cookie>
```

</Slide>

---

<Slide>

# Specifications

- Custom Elements
- Shadow DOM
- ES Modules
- HTML Template

</Slide>

---

<Section bg={2} logo="white">

# Custom Elements


</Section>

---

<Slide>

# Custom Elements / Built-in Elements

<Image src="./adesso/images/Element_properties_Ancestry.png" />

#### hier soll standard html element Vererbung erklärt werden

</Slide>

---


<Slide>

# Built-in Elements
- Built-in Elements Technologie ermöglicht erweiterung eines HTML-Element
- Normales HTML mit der Attribut <b>is</b> ausstatten
#### erweitern eines input element 
#### steht noch offen ob wir zuerst built-in erklären wollen 

</Slide>

---

<Slide>

# Built-in Elements
 ```html
 <input is="dw-input"></input>
 ```

</Slide>

---



<Slide>

# Custom Elements  Boilerplate
```JS
class YourClassName extends HTMLElement{
    constructor(){
        super();
        /* define your element .... */
    }
}
window.customElements.define("your-tag", YourClassName);
```
```html
<your-tag></your-tag>
```

</Slide>

---

<Slide>

# Custom Elements Constructor
- Definieren eines Custom Elements
```JS
class YourClassName extends HTMLElement{
    constructor(){
        super();
        /* define your element .... */
    }
}
```

</Slide>

---

<Slide>

# Custom Elements Registry

- Registrieren der Element


```JS
window.customElements.define("your-tag", YourClassName);
```

</Slide>



---

<Slide>

# Custom Elements 
 ```html
 <dw-input theme="blue"></dw-input>
 ```





</Slide>

---

<Slide>

# Custom Elements 

```JS
class DWInput extends HTMLElement{
    constructor(){
        super()
       /*  */
    }
}
window.customElements.define("dw-input", DWInput);

```




</Slide>

---
<Slide>

# Übung 1

1. Definiere ein eigenes "custom" HTML Tag 
2. Kreiere ein Custom Element Objekt
3. Wenn initialisiert, es soll in JS-definiertes Text rendern (z.B. eigene Name) 


</Slide>

---

<Section bg={3} logo="white">

# Shadow DOM


</Section>

---

<Slide>
  
# Shadow DOM  

"Web components are a set of web platform APIs that allow you to create new custom, reusable, <i>encapsulated</i> HTML tags to use in web pages and web apps."

- Fokus auf "encapsulated" 


</Slide>

---

<Slide>

# Shadow DOM  

  - per definition ist es möglich "encapsulated" Komponeten zu kreieren
  - alles innerhalb eine Komponente definiert (HTML, CSS)
    

</Slide>

---

<Slide>

<Image src="./adesso/images/shadow-root-elements.png" />

    

</Slide>

---

<Slide>

```JS
// shadow-root nodeType = 11
// document-fragment
```    
- document-fragment ist vereinfachte version des document
- eine hat kein Einflus auf das andere

</Slide>

---

<Slide>
    
# Shadow DOM  

```JS
class DWInput extends HTMLElement{
    constructor(){
       super();
        const shadowRoot = this.attachShadow({mode: 'open'});
        // shadowRoot.appendChild(yourChild);
    }
}
window.customElements.define("dw-input", DWInput);

```


</Slide>

---

<Slide>

# Übung #2
- Übung #1 mit Shadow DOM erweitern
- Eigenes text jetzt in shadowRoot rendern

</Slide>

---

<Slide>

# Shadow DOM Styles
- Möglichkeit um CSS zu definieren der nur für Komponente gültig ist 

</Slide>

---

<Slide>

# Shadow DOM Styles
```JS

    constructor(){
       super();
        const shadowRoot = this.attachShadow({mode: 'open'});
        const style = document.createElement('style');
        style.textContent = `p { color: red; }`;
        shadowRoot.appendChild(style);
    }
```

</Slide>

---

<Slide>

# Übung #3
- Eigene shadowRoot Styles definieren

</Slide>

---

<Section bg={5} logo="white">

# HTML Templates/ Slots

</Section>

---

<Slide>

# Html Templates
- Bietet Möglichkeit "reusable" Templates zu definieren 

</Slide>

---

<Slide>

# Html Templates
```html
<template id="dw-template">
    <p> Das ist ein Text </p>
</template>
// Bleibt auf der Seite unsichtbar
```

</Slide>

---

<Slide>

# Html Templates
```JS

    constructor(){
       super();
        const shadowRoot = this.attachShadow({mode: 'open'});
        const template = document.querySelector('#dw-template');
        const templateContent = template.content;
        shadowRoot.appendChild(templateContent.cloneNode(true));
    }
```

</Slide>

---

<Slide>

# Übung #4

</Slide>

---

<Section bg={4} logo="white">

# Callbacks


</Section>

---
<Section bg={4} logo="white">

# Polyfills


</Section>

---
<Section bg={4} logo="white">

# Frameworks


</Section>

---
<Section bg={4} logo="white">

# Implementation bestehende Komponetnen 


</Section>

---
