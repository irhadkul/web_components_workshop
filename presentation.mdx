import future from "@mdx-deck/themes/future";
import highlight from "@mdx-deck/themes/syntax-highlighter-prism";
import { Split } from "@mdx-deck/layouts";
import { Notes, Appear } from 'mdx-deck'
import { FullScreenCode } from 'mdx-deck';
import { Title, Slide, Section, Image, theme } from "./adesso";

export const themes = [theme, highlight];


<Title bg="rgb(241, 237, 233)">

# Web Components
## benutzerdefinierte HTML-Elemente

Workshop mit Irhad Kulanic und Lukas Korten

</Title>

---

<Section bg="#618792" logo="white">

# Ein weiteres Framework?  

</Section>

---

<Section bgSrc="./adesso/images/JS-Frameworks.png" logo="white"></Section>

---

<Slide>

# Web Components    

- Eine Gruppe von Webtechnologien
- benutzerdefinierte und wiederverwendbare HTML-Elemente
- in sich gekapselte Funktionalität
- einsetzbar auf allen Webseiten und in allen Frameworks

<Notes>
# Datepicker als Beispiel nennen:
Wieviele Datepicker wurden in den letzten Jahren immer wieder aufs neue implementiert, 
um in dem letzten gehypten JavaScript-Framework zu funktionieren? 
Mit Web Components soll sich das Blatt wenden: 
Die Komponente wird einmal implementiert und kann überall wiederverwendet werden.
</Notes>

</Slide>

---

<Slide>

# Die Haupttechnologien

<ul>    
    <li>Custom Elements</li>
    <li>Shadow DOM</li>
    <li>HTML-Templates</li>
    <Appear>
        <li>(ES Modules)</li>
    </Appear>
</ul>

<Notes>
- siehe Standard: https://github.com/w3c/webcomponents
- HTML Modules sind noch nicht Living Standard. Nachfolger von HTML Imports
- Specs sind maintained von unterschiedlichen Gruppen: HTML Standards, DOM Standards, CSS WG
- von unterschiedlichen Arbeitsgruppen entwickelt
- sind Living Standard und werden von allen modernen Browsern (Ausnahme Edge)
</Notes>

</Slide>

---

<Section bg="#774251" logo="white">

# Custom Elements
## Benutzerdefinierte HTML-Elemente

</Section>

---

<Slide>

# Custom Elements

`CustomElementRegistry`
* Controller für benutzerdefinierte Elemente
* global über `customElements` zugreifbar

<br/>

`CustomElementRegistry.define()` - registriert ein neues Custom Element

**Argumente**
* Name des Elements (Ein `-` im Namen ist Pflicht)
* Das Verhalten definierende Klassenobjekt 

<Notes>
    - CustomElementRegistry ist ein Controler für Custom Elements in einem Web-Dokument
    - darüber kann ein Custom Element registriert und Informationen über ein vorhandenes abgefragt werden
</Notes>

</Slide>

---

<Slide>

# Custom Elements

**Das Klassenobjekt**
* ES 2015 Standardsyntax für Klassen


```
class MyPopup extends HTMLElement {     
    constructor() { 
        super(); // muss immer als erstes aufgerufen werden

        // Funktionalität des Elements
        ...    
    }
}
```

</Slide>

---

<Slide>

# Custom Elements

**Zwei Arten**
* autonome Custom Elements
* erweiterte Standardelemente (built-in elements)

</Slide>

---

<Slide>

# Custom Elements

**Autonome Custom Elements**
* erben direkt vom `HTMLElement`
* nicht von Standardelementen wie z.B. `HTMLInputElement`
* Name kann als Tag verwendet werden

</Slide>

---

<Slide>

# Custom Elements

```
class MyPopup extends HTMLElement {     
    constructor() { ... }
}

customElements.define('my-popup', MyPopup);
```

</Slide>

---

<Slide>

# Custom Elements

Kann mit dem Namen `my-popup` erzeugt werden
* JavaScript
```
document.createElement('my-popup');
```
* HTML
```
<my-popup></my-popup>
```
</Slide>

---

<Slide>

# Custom Elements

**Erweiterte Standardelemente (Built-in Elements)**
* erben von Standardelementen
* Beim Erstellen Angabe des erweiterten Standardelement-Tags erforderlich
* Mit dem Attribut `is` wird der Name des Elements angegeben

</Slide>

---

<Image src="./adesso/images/Element_properties_Ancestry.png" width="80vw"/>

<Notes>
- hier soll die Vererbung erklärt werden
- HTMLInputElement erbt von HTMLElement und bringt eigene Funktionalität mit, z.B. value, type usw.
</Notes>

---


<Slide>

# Custom Elements

```
class MyAlert extends HTMLParagraphElement { 
    constructor() { ... } 
}

customElements.define('my-alert', MyAlert, { extends: 'p' });
```

</Slide>

---

<Slide>

# Custom Elements

Beim Erzeugen muss das Attribut `is` angegeben werden 

* JavaScript
```
document.createElement('p', { is: 'my-alert' });
```

* HTML
```
<p is="my-alert"></p>
```

</Slide>

---

<Section bg="#618792" logo="white">

# DEMO 1
## Custom Element   

</Section>

---

<Slide>

# Custom Elements
## Übung 1 - Visitenkarte

Implementiert eine Visitenkarte als ein **automares Custom Element**. 
Die Visitenkarte soll zunächst einen beliebigen Namen und eines der Bilder aus dem Verzeichnis `uebungen/global/images/` anzeigen.
Als Einstiegspunkt nutzt bitte die Datei `Uebung_1/index.js`. In dieser Datei ist auch eine kleine Anleitung für die Übung hinterlegt.

![Aufgabe 1](../adesso/images/Aufgabe_1.png)

</Slide>

---

<Section bg="#774251" logo="white">

# Shadow DOM
## Kapselung von CSS und HTML

</Section>

---

<Slide>

# Shadow DOM  

* ein isollierter *Subtree* mit eigenem Markup und Styling
* wird unabhängig vom DOM des Hauptdokuments gerendert
* kolliediert nicht mit Skripten und Styles des Hauptdokuments
* Elemente im Shadow DOM sind über `document.querySelector()` nicht zugreifbar
    
<Notes>
- Skripte und Styles können angewendet werden, ohne dass sie mit anderen Teilen des Dokuments kollidieren
</Notes>

</Slide>

---

<Slide>

# Shadow DOM  

<Split>

![Browser](./adesso/images/Shadow-DOM-Browser.png)

![Entwicklertools](./adesso/images/Shadow-DOM-Entwicklertools.png)

</Split>

<Notes>
- shadow-root nodeType = 11
- document-fragment  
- document-fragment ist eine vereinfachte Version des document
- das eine hat keinen Einfluss auf das andere
- Vergleich mit iFrames 
</Notes>

</Slide>

---

<Slide>

# Shadow DOM  

* **Shadow host** - Der DOM-Knoten, an dem das Shadow DOM hängt
* **Shadow tree** - Der DOM-Tree (Struktur) des Shadow DOM
* **Shadow boundary** - Der Geltungsbereich des Shadow DOM
* **Shadow root** - Der Root-Knoten des DOM-Tree 

</Slide>

---

<Slide>

# Shadow DOM

```
class MyComponent extends HTMLElement {    
    constructor() {
        super();
        
        this.attachShadow({ mode: 'open' });        
        const childElement = document.createElement('p');
        this.shadowRoot.appendChild(childElement);               
    }
}
customElements.define("my-component", MyComponent);
```

<Notes>
Unterschied zwischen 'open' und 'closed': 
Mit 'open' kann über shadowRoot auf Elemente zugegriffen werden, mit 'closed' nicht

</Notes>

</Slide>

---

<Slide>

# Shadow DOM
* `open` vs `closed`

![](./adesso/images/Shadow-DOM-closed.gif)

</Slide>

---

<Section bg="#618792" logo="white">

# DEMO 2
## Shadow DOM 

</Section>

---

<Slide>

# Shadow DOM
## Übung 2 - Visitenkarte mit Shadow DOM erweitern

In dieser Übung soll das bereits entwickelte Custom Element `DWContactCard` mit Shadow DOM erweitert werden.
Einstiegsdatei mit zusätzlichen Hinweisen: `uebungen/Uebung_2/index.js`

![Aufgabe 2 Bild](../adesso/images/Aufgabe_2.png)

</Slide>

---

<Slide>

# Shadow DOM - Styles

- Im Shadow DOM definiertes CSS wirkt sich nur auf angehängte Elemente aus 
- globales CSS hat keinen Einfluss auf Elemente im Shadow DOM 

<Notes>
- Beispiel wie andere Framework das schaffen (css Klasse: some_ysda84874)
</Notes>

</Slide>

---

<Slide>

# Shadow DOM - Styles

```
constructor(){
    super();
    
    const style = document.createElement('style');
    style.textContent = `p { color: red; }`;
    
    this.attachShadow({ mode: 'open' });
    this.shadowRoot.appendChild(style);
}
```

</Slide>

---

<Section bg="#618792" logo="white">

# DEMO 3
## Shadow DOM Styles

</Section>

---

<Slide>

# Übung #3
- Eigene shadowRoot Styles definieren und damit das Problem das wir in Übung 2 verursacht haben korrigieren.
1. kreiere neues styles Element in JS "document.createElement('style');"
2. setzte dessen Inhalt auf : "img { max-width:200px; }"
3. Füge neues Style Element ins Shadow DOM hinzu.


</Slide>

---

<Section bg={5} logo="white">

# HTML Templates/ Slots

</Section>

---

<Slide>

# HTML Templates
- ein Teil der web components Standard 
- bietet Möglichkeit "reusable" Templates zu definieren 
- definiert in HTML oder JS

</Slide>

---

<Slide>

# HTML Templates
```html
<template id="dw-template">
    <p> Das ist ein Text </p>
</template>
// Bleibt auf der Seite unsichtbar
```

</Slide>

---

<Slide>

# HTML Templates
- Neues HTML Tag "template"
- Bleibt unsichtbar bis es initialisiert ist
- Soll mit ID ausgestattet werden 

</Slide>

---

<Slide>

# HTML Templates
```JS

    constructor(){
       super();
        const shadowRoot = this.attachShadow({mode: 'open'});
        const template = document.querySelector('#dw-template');
        const templateContent = template.content;
        shadowRoot.appendChild(templateContent.cloneNode(true));
    }
```

</Slide>

---

<Slide>

# HTML Templates
- wie gewohnt aus document abfragen
- dessen Inhalte ins shadowRoot einfügen

</Slide>

---

<Slide>

# HTML Templates
## Demo #4


</Slide>

---

<Slide>

# Übung #4

- schreibe eigene HTML Template in "uebungen/Uebung_4-HTMLTemplate/index.html"
- Alle in JS definierte HTML Elementen schiebe in Template Element und lösche den aus JS Datei.
- füge die HTML Template ins shadowRoot ein


</Slide>

---

<Slide>

# HTML Slots
- Teil der Template Standard
- Bietet Möglichkeit Platzhalter zu definieren

</Slide>

---

<Slide>

# HTML Slots
- auf zwei Stellen definiert:
1. In HTML Teil der web-Komponente
2. In Template HTML

</Slide>

---

<Slide>

# HTML Slots 
- in HTML Teil der Web-Komponente definieren wir den Inhalt
- das Inhalts-Element ist mit der Attribut "Slot" ausgestattet
```html
<dw-cookie visible> <div slot="cookie-text">Wir verwenden Cookies...</div></dw-cookie>
```

</Slide>

---

<Slide>

# HTML Slots 
- in Template definieren wir den Platzhalter
- in Template Tag sind Slots mit eigenem Tag definiert
- Haben entsprechend die Name gesetzt
```html
<template id="dw-cookieTemplate">
    <slot name="cookie-text"></slot>
</template>
```

</Slide>

---

<Slide>

# HTML Slots in JS
```JS
    constructor(){
       super();
        const shadowRoot = this.attachShadow({mode: 'open'});
        const template = document.querySelector('#dw-cookieTemplate');
        const templateContent = template.content;
        shadowRoot.appendChild(templateContent.cloneNode(true));
    }
```

</Slide>

---

<Slide>

# HTML Slots in HTML
```html
<template id="dw-cookieTemplate">
    <slot name="cookie-text"></slot>
</template>
<dw-cookie visible> <div slot="cookie-text">Wir verwenden Cookies...</div></dw-cookie>
```

</Slide>

---

<Slide>

# HTML Slots
## Demo #5

</Slide>

---

<Slide>

# Übung #5
- Definiere zwei Slots in HTML Template, ein für das Bild und ein für Info
- Inhalt für Slots in der Web-Komponente HTML definieren

##### In Template sind die Slots mit z.B. "slot name='test' tag zu kreieren und in den Elementen selbst sollen die HTML Elementen Attribut "slot" haben ("div slot='test'")
![Aufgabe 5](../adesso/images/Aufgabe_5.png)

</Slide>

---

<Section bg={4} logo="white">

# Callbacks


</Section>

---

<Slide>

# Callbacks
- Bestandteil eine Komponente
- Ermöglichen Kontrolle bei Änderungen

</Slide>

---

<Slide>

# Callbacks
- connectedCallback
- disconnectedCallback
- adoptedCallback
- attributeChangedCallback

</Slide>

---

<Slide>

# connectedCallback
- passiert bei jedem Einfügen, und Schieben der Komponente HTML
- kann mehrmals aufgerufen werden
- wenn die Komponente auf inneren oder äußeren DOM abhängig ist


</Slide>

---

<Slide>

# connectedCallback
```JS
    constructor(){
       super();
    }
    connectedCallback(){
        // bei Zugriff auf DOM 
        // Beispiel: Berechnete Styles abfragen
    }
```

</Slide>

---

<Slide>

# disconnectedCallback
- bei "disconnecten" oder löschen von der Seite 
```JS
    constructor(){
       super();
    }
    disconnectedCallback(){
        // Beispiel: setzte alles auf null 
        // oder remove eventListeners
    }
```

</Slide>

---

<Slide>

# adoptedCallback
- bei Schieben der Komponente zu anderen document, z.B. iframe
- soll nur in komplexen Fällen benutzt werden wo connectedCallback nicht ausreicht

<Notes>
- nur kurz erwähnen, ist nur in komplexen fällen zu benutzen 
</Notes>

</Slide>

---

<Slide>

# adoptedCallback
```JS
    adoptedCallback(){
        // Beispiel: 
        // wechsel der ownerDocument
        // HTML -> iframe mit adoptNode()  
    }
```
</Slide>

---

<Slide>

# Callbacks
## Demo #6

</Slide>

---

<Slide>

# Übung #6
// TODO: überlegen ob wir es zusammen mit der Aufgabe 7 machen sollen

</Slide>

---

<Slide>

# attributeChangedCallback
- Ermöglicht Kontrolle über Attributen Änderungen (Add, Edit, Remove)
- Eigene Komponenten "native-like" machen 
- Bietet dem Anwender Möglichkeit der Inhalt zu Ändern
- Zum Beispiel: reagieren auf "Theme" Attribut Änderung  

</Slide>

---

<Slide>

# attributeChangedCallback
- besteht aus zwei Teilen:
1. callback Methode
2. static get "observedAttributes"

</Slide>

---


<Slide>

# attributeChangedCallback
1. callback Methode (attributeChangedCallback)
- wird jedes Mal ausgeführt bei Attributen Änderungen

</Slide>

---


<Slide>

# attributeChangedCallback
1. static get observedAttributes
- definieret auf welchen Attributen die callback Methode reagieren soll

</Slide>

---

<Slide>

# attributeChangedCallback

```JS
static get observedAttributes(){
    // return ist immer ein Array
    return ['text-color']
}
constructor(){super}
attributeChangedCallback(attrName, oldValue, newValue){}
```

</Slide>

---

<Slide>

# Callbacks attributeChangedCallback
## Demo #7

</Slide>

---

<Slide>

# Übung #7
- Die Komponente soll sich wie ein HTML Element Verhalten
- Es soll entsprechend auf Attributen-Änderungen reagieren
- Wenn der Benutzer ein Attribut z.B. "name" ändert oder hinzufügt, es soll auch in der Komponente angezeigt werden

![Aufgabe 7](../adesso/images/Aufgabe_7.png)

</Slide>

---

<Section bg={6} logo="white">

# Polyfills


</Section>

---

<Slide>

# Polyfills
- kleine Bibliotheken die Browser um eine Technologie erweitern
- dadurch können z.B. ältere Versionen von Browsers profitieren

</Slide>

---

<Slide>

# Polyfills
![Source: https://www.webcomponents.org/ 
TODO: Das Bild beschreiben
](./adesso/images/WC-polyfill-status.png)


</Slide>

---

<Slide>

# Polyfills
- Obwohl web componets "living-standard" sind, brauchen ältere Versionen oder verschiedene Browsers polyfills 
- empfohlenes polyfill:
https://www.webcomponents.org/polyfills

<Notes>
- TODO:
</Notes>

</Slide>

---

<Slide>

# Polyfills
- können zu Performance Reduzierung führen
- manche Technologien lassen sich nicht "polyfillen", z.B. shadow DOM in IE 11 (Über shadyCSS möglich)

<Notes>
- shadyCSS macht das gleiche was andere framework machen, kreiert einzigartige css Klassen 
- ist mit Vorsicht zu genießen, vor allem bei langsamere Browsers (paradox)
</Notes>
</Slide>

---

<Slide>

# Polyfills Einbindung
```html
<!-- load the webcomponents loader, which injects the necessary polyfill bundle -->
<script src="node_modules/@webcomponents/webcomponentsjs/webcomponents-loader.js"></script>

<!-- load the element -->
<script type="module" src="my-element.js"></script>

<!-- use the element -->
<my-element></my-element>
```

</Slide>

---

<Slide>

# Polyfills Einbindung
## Demo #8

</Slide>

---

<Section bg={7} logo="white">

# Frameworks


</Section>

---

<Slide>

# Frameworks
## Warum Frameworks?

- Erweitern Funktionalität
- Erleichtern Aufsetzen von Dev Umgebung
- Sparen Boilerplate Code


</Slide>

---

<Slide>

# Frameworks
## Ein paar bekannte Frameworks:

1. Polymer Project
2. Angular Elements
3. Stencil

</Slide>

---



<Slide>

# Frameworks
## Polymer Project

- Bibliotheken und Tools für bauen von web components
- zwei bekannteste Librarys:
1. lit-html
2. LitElement

</Slide>

---

<Slide>

# lit-html

- schnelle HTML-Templating Library
- bauen und updaten von JS HTML Templates
- re-rendering nur von diffs

</Slide>

---

<Slide>

# lit-html

```js
const myTemplate = (name) => html`
    <div>
      Hi, my name is ${name}.
    </div>
`;
```
</Slide>

---



<Slide>

# LitElement

- Custom Components base class
- erweitert die Custom Componente mit z.B. neuen Callbacks
- Komponenten und Properties werden mit Annotations deklariert

</Slide>

---

<Slide>

# LitElement

![Code Beispiel leider als bild da es Problemen mit mdx deck macht](./adesso/images/lit-element-beispiel.png)

<Notes>
Link zu code Beispiel :
https://lit-element.polymer-project.org/guide/start#use-litelement-typescript-decorators
</Notes>

</Slide>

---




<Slide>

# Frameworks
## Angular Elements
- Angular Elements gebaut zu web components
- Custom components mit angular Elements features wie change detection, data binding und dynamic content (HTML)
- Registrieren sich wie normale Custom Components 
- können einzeln ins HTML eingebunden werden 

</Slide>

---

<Slide>

# Angular Elements
## Registrierung Ablauf
![Source: https://angular.io/guide/elements](./adesso/images/angular-elements.png)

</Slide>

---

<Slide>

# Angular Elements
## Angular Element nach export

```html
<my-popup message="Use Angular!"></my-popup>

```

</Slide>

---

<Slide>

# Stencil

>Stencil is a toolchain for building reusable, scalable Design Systems. Generate small, blazing fast, and 100% standards based Web Components that run in every browser.

</Slide>

---

<Slide>

# Stencil
- erweitert web componets mit neuen callbacks, props/attributes
- TypeScript per Default
- JSX oder React Style HTML
- Implementiert Dev umgebung
- Polyfills 
- 100% web components zu Laufzeit

</Slide>

---

<Slide>

# Stencil
```js
import { Component, Prop, h } from '@stencil/core';
@Component({ tag: 'my-first-component',})
export class MyComponent {
  @Prop() name: string;
  render() {
    return (<p> My name is {this.name} </p>
    );
  }
}

```

</Slide>

---


<Slide>

# Stencil
```html
<my-first-component name="Max"></my-first-component>
```

</Slide>

---

<Slide>

# Stencil Decorators
* **@Component()** declares a new web component
* **@Prop()** declares an exposed property/attribute
* **@State()** declares an internal state of the component
* **@Watch()** declares a hook that runs when a property or state changes
* **@Element()** declares a reference to the host element
* **@Method()** declares an exposed public method
* **@Event()** declares a DOM event the component might emit
* **@Listen()** listens for DOM events


</Slide>

---
<Slide>

# Stencil Callbacks
* **connectedCallback()** 
* **disconnectedCallback()** 
* **componentWillLoad()** 
* **componentDidLoad()** 
* **componentWillRender()** 
* **componentDidRender()** 
* **componentWillUpdate()**
* **componentDidUpdate()**
* **render()**


</Slide>

---

<Slide>

# Stencil Aufsetzen
## Demo #9

</Slide>

---

<Section bg={8} logo="black">

# Implementation bestehende Komponenten 


</Section>

---

<Slide>

# Implementation bestehende Komponenten 
- web components sind Valides HTML
- lassen sich in jedes Framework einsetzen 
- größer Auswahl einzelne Komponenten z.B.

1. https://www.webcomponents.org/elements
2. https://www.npmjs.com/search?q=keywords:web-components

</Slide>

---

<Slide>

# Implementation bestehende Komponenten  
- um bestehende Komponenten zu importieren hat man mehrere Möglichkeiten:
1. npm Paket ins Projekt importieren
2. Script in HTML Document
3. JS modul (JS import * from)

</Slide>

---

<Slide>

# Implementation bestehende Komponenten  
## Demo #10
- npm i @vaadin --save
- import '@vaadin/vaadin-date-picker/vaadin-date-picker';

<Notes>
    - vaadin Komponenten: https://vaadin.com/components/vaadin-date-picker/html-examples
</Notes>

</Slide>

---